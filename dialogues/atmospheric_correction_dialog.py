# -*- coding: utf-8 -*-
"""
/***************************************************************************
 AtmosphericCorrectionDialog
                                 A QGIS plugin
 This is a plugin to perform atmospheric correction on multispectral images
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-10-05
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Edmond Baloku
        email                : edmondbv@hotmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import shutil

from PyQt5.QtWidgets import QFileDialog, QDialog
import PyQt5.uic as uic
from PyQt5.QtGui import QImage, QPixmap

import cv2
import spectral.io.envi as envi
import numpy as np

# import the function radiometric_correction from radiometric_correction.py
from .radiometric_correction import radiometric_correction



# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'atmospheric_correction_dialog_base.ui'))


class AtmosphericCorrection(QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(AtmosphericCorrection, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect

        self.setupUi(self)

        self.open_file_button.clicked.connect(self.set_path_to_file)
        self.calibrate_image_button.clicked.connect(self.set_calibrated_rgb)
        self.set_rgb_button.clicked.connect(self.set_original_rgb)
        self.save_img_button.clicked.connect(self.set_path_to_directory)

        # TODO: Implement atmospheric correction and classify water properly
        # self.atmospheric_correction_button.clicked.connect(self.atmospheric_correction)
        # self.classify_water_button.clicked.connect(self.classify_water)

        self.input_exp.editingFinished.connect(self.set_exp)

        self.path_to_file = ""
        self.path_to_directory = ""

        self.exp = 0.035
        self.original_rgb = (60, 80, 90)
        self.calibrated_rgb = (70, 50, 35)


    def set_path_to_file(self):
        try:
            options = QFileDialog.Options()
            self.path_to_file, _ = QFileDialog.getOpenFileName(self, "", "", "HDR Files (*.hdr)", options=options)
            self.open_file()

        except Exception as err:
            print("Error: " + str(err))


    def set_path_to_directory(self):
        try:
            options = QFileDialog.Options()
            self.path_to_directory, _ = QFileDialog.getSaveFileName(self, "", self.path_to_file[:-4] + "_calibrated", "PNG File (*.png) ;; JPEG File (*.jpeg) ;; PDF File (*.pdf)", options=options)
            self.save_image()

        except Exception as err:
            print("Error: " + str(err))


    def set_exp(self):
        if self.input_exp.text() != "":
            self.exp = float(self.input_exp.text())



    def set_original_rgb(self):
        if self.input_rgb.text() != "":
            self.original_rgb = tuple(map(int, self.input_rgb.text().split(",")))
            self.open_file()


    def set_calibrated_rgb(self):
        if self.input_rgb.text() != "":
            self.calibrated_rgb = tuple(map(int, self.input_rgb.text().split(",")))
            self.calibrate_image()

        else:
            self.calibrated_rgb = (70, 50, 35)
            self.calibrate_image()


    def open_file(self):
        if self.path_to_file != "":
            original_img = self.get_img_from_hdr(self.path_to_file, rgb=self.original_rgb)
            self.show_img(original_img, self.label_original_img, swap_rgb=True)


    def get_img_from_hdr(self, path_to_file, rgb):

        img = envi.open(path_to_file)

        img_array = img.load()
        img_array = img_array[:,:,(rgb)]
        img_array = ((img_array - img_array.min()) / img_array.max() * 255).astype(np.uint8)
        np_img = np.array(img_array)

        img = cv2.cvtColor(np_img, cv2.COLOR_BGR2RGB)

        return img


    def show_img(self, img, label, swap_rgb):
        height, width, _ = img.shape
        bytes_per_line = 3 * width
        q_img = QImage(img.data, width, height, bytes_per_line, QImage.Format_RGB888)

        if swap_rgb:
            q_img = q_img.rgbSwapped()

        label.setPixmap(QPixmap.fromImage(q_img))


    # TODO: Implement better algorithm for classifying water
    def classify_water(self):
        try:
            original_img = envi.open(self.path_to_file)
            wl = list(map(float, original_img.metadata["wavelengths"]))
            wl = wl[::-1] # needed to get corresponding order of spectra and wavelengths

            new_img_array = np.zeros((original_img.shape[0],original_img.shape[1]))

            for i in range(original_img.shape[0]):
                for j in range(original_img.shape[1]):
                    pixel = original_img.read_pixel(i,j)
                    wl_750 = pixel[wl.index(749.5798319327731)]
                    wl_763 = pixel[wl.index(763.0252100840336)]

                    if wl_750 > wl_763:
                        diff = wl_750 - wl_763
                        if diff > 3000:
                            new_img_array[i,j] = 1

            new_img_array = new_img_array[:,:]
            new_img_array = ((new_img_array - new_img_array.min()) / new_img_array.max() * 255).astype(np.uint8)
            np_img = np.array(new_img_array)
            self.new_img = cv2.cvtColor(np_img, cv2.COLOR_BGR2RGB)

            self.show_img(self.new_img, self.label_new_img, swap_rgb=True)

        except Exception as err:
            print("Error:", str(err))


    def save_image(self):
        if self.path_to_directory != "":
            cv2.imwrite(self.path_to_directory, self.new_img)


    def calibrate_image(self):
        try:
            bip_path = self.path_to_file[:-4] + ".bip"
            cube_calibrated, self.w = radiometric_correction(bip_path, self.exp)
            print('self.exp', self.exp)

            cube_calibrated.astype(dtype = 'float16').tofile(self.path_to_file[:-4] + "_calibrated.bip")
            self.calibrated_hdr_path = shutil.copy2(self.path_to_file, self.path_to_file[:-4] + "_calibrated.hdr")

            calibrated_img = self.get_img_from_hdr(self.calibrated_hdr_path, rgb=self.calibrated_rgb)
            self.show_img(calibrated_img, self.label_new_img, swap_rgb=True)

            return cube_calibrated, self.w

        except Exception as err:
            print("Error: " + str(err))

    # TODO: Implement Empirical Line Fits for atmospheric correction: https://www.oceanopticsbook.info/view/atmospheric-correction/level-2/empirical-line-fits
    def atmospheric_correction(self):
        pass

   