# -*- coding: utf-8 -*-
"""
/***************************************************************************
 TargetDetectionDialog
                                 A QGIS plugin
 This plugin allows you to find probability of similarity in spectral intensity across a multispectral image
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-10-28
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Markus Haldorsen
        email                : markushaldorsen@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from PyQt5.QtWidgets import QFileDialog, QDialog
import PyQt5.uic as uic
from PyQt5.QtGui import QImage, QPainter, QPen, QBrush, QColor, QPixmap

import cv2
import spectral.io.envi as envi
import spectral as spy
import numpy as np

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'target_detection_dialog_base.ui'))


class TargetDetectionDialog(QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(TargetDetectionDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        
        self.pbOpenFile.clicked.connect(self.set_path_to_file)
        self.pbSetCoord.clicked.connect(self.set_coordinates)
        self.pbGenerate.clicked.connect(self.generate)
        self.pbDone.clicked.connect(self.close)
        
        self.sldThreshold.valueChanged.connect(self.set_threshold_by_slider)
        
        self.leXCoord.editingFinished.connect(self.set_x_coord)
        self.leYCoord.editingFinished.connect(self.set_y_coord)
        self.leThreshold.editingFinished.connect(self.set_threshold_by_input)
        
        self.threshold = 0.5
        self.path_to_file = ""
        self.x_coord = 0
        self.y_coord = 0

    def set_path_to_file(self):
        options = QFileDialog.Options()
        fileName, _ = QFileDialog.getOpenFileName(self, "QFileDialog.getOpenFileName()", "", "HDR Files (*.hdr)", options=options)
        self.path_to_file = fileName
        
        self.open_file()
            
    def get_path_to_file(self):
        return self.path_to_file
    
    def open_file(self):
        if self.path_to_file != "":
            print("filename: ", self.path_to_file) 
            self.lblPathToFile.setText("Path to file: \n" + self.path_to_file)
 
            self.show_image()
        else:
            self.lblPathToFile.setText("Path to file: \nNo file selected")
            
    def set_x_coord(self):
        if self.leXCoord.text() != "":
            self.x_coord = int(self.leXCoord.text())
        else: 
            self.x_coord = 0
            
        self.show_image()
        
    def set_y_coord(self):
        if self.leYCoord.text() != "":     
            self.y_coord = int(self.leYCoord.text())
        else:
            self.y_coord = 0
            
        self.show_image()
        
    def set_coordinates(self):
        self.set_x_coord()
        self.set_y_coord()
    
    def get_x_coord(self):
        return self.x_coord
    
    def get_y_coord(self):  
        return self.y_coord
            
    def set_threshold_by_slider(self):
        self.threshold = self.sldThreshold.value() / 10000
        self.leThreshold.setText(str(self.threshold))
        
        print("New threshold: ", self.threshold)
        
    def set_threshold_by_input(self):
        self.threshold = float(self.leThreshold.text())
        sldThresholdValue = int(self.threshold * 10000)
        self.sldThreshold.setValue(sldThresholdValue)
        
        print("New threshold: ", self.threshold)
        
    def get_threshold(self):
        return self.threshold
    
    def generate(self):
        print("Generate")
        
        # TODO: Generate correlation coefficient algorithm
        # Show result
        
    def show_image(self):
        print("show_image")
        img = self.get_image_from_hdr()

        height, width, _ = img.shape
        bytesPerLine = 3 * width
        qImg = QImage(img.data, width, height, bytesPerLine, QImage.Format_RGB888).rgbSwapped()
        
        painter = QPainter(qImg)
        painter.setPen(QPen(QColor(255, 0, 0), 10))
        painter.drawPoint(self.y_coord, self.x_coord) # X and Y are opposite order because it is what it is.
        painter.end()
        
        self.lblImage.setPixmap(QPixmap.fromImage(qImg))
        
        
    ## NOTE ##
    # To make this work, you need to install the spectral library and opencv-python librari in QGIS.
    # Go to QGIS -> python consol:
    #   import pip
    #   pip.main(['install', 'spectral'])
    #   pip.main(['install', 'opencv-python'])
    # Restart QGIS
    def get_image_from_hdr(self):
        print("get_image_from_hdr")
        full_img = envi.open(self.path_to_file)
        img_array = full_img.load()
        
        
        R = 60
        G = 80
        B = 90
        
        img_array = img_array[:,:,(R,G,B)]
        img_array = img_array - img_array.min()
        img_array = img_array / img_array.max()
        img_array = img_array * 255 
        img_array = img_array.astype(np.uint8)
        
        np_img = np.array(img_array)
        img = cv2.cvtColor(np_img, cv2.COLOR_BGR2RGB)
        
        return img
